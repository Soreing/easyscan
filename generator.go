package easyscan

import (
	"bytes"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"
)

type Case int

const (
	LOWER_CASE Case = iota
	CAMEL_CASE
	PASCAL_CASE
	SNAKE_CASE
	KEBAB_CASE
)

type Generator struct {
	buf         bytes.Buffer
	pkgName     string
	anyorder    bool
	defaultCase Case
}

// Creates a new Generator
func NewGenerator() *Generator {
	return &Generator{
		buf:         bytes.Buffer{},
		pkgName:     "",
		anyorder:    false,
		defaultCase: LOWER_CASE,
	}
}

// Sets target package name
func (g *Generator) SetPackage(pkg string) {
	g.pkgName = pkg
}

// Sets reading columns into struct fields in any order
func (g *Generator) SetAnyOrder(ao bool) {
	g.anyorder = ao
}

// Sets default casing of the column names
func (g *Generator) SetDefaultCase(cs Case) {
	g.defaultCase = cs
}

// Writes into the generator's buffer
func (g *Generator) Printf(f string, v ...any) {
	g.buf.WriteString(fmt.Sprintf(f, v...))
}

// Gets the content of the generator's buffer
func (g *Generator) ReadAll() []byte {
	return g.buf.Bytes()
}

// Writes the header for the file
func (g *Generator) WriteHeader() {
	g.buf.WriteString("// Code generated by easyscan for scanning sql rows. DO NOT EDIT.\n")
	g.buf.WriteString("package " + g.pkgName + "\n")
	g.buf.WriteString("\n")
	g.buf.WriteString("import \"github.com/Soreing/easyscan\"\n")
	g.buf.WriteString("\n")
}

// Creates code for a struct implementing easyscan.ScanRow
func (g *Generator) AddScanStruct(st Struct) {
	fields := []string{}
	aliases := []string{}

	for _, field := range st.fields {
		alias, omit := parseTag(field.tag)
		if !omit {
			if alias == "" {
				alias = caseString(field.name, g.defaultCase)
			}
			fields = append(fields, field.name)
			aliases = append(aliases, alias)
		}
	}

	g.buf.WriteString(
		makeScanRow(st.name, fields, aliases, g.anyorder),
	)
}

// Creates code for a slice implementing easyscan.ScanAppendRow
func (g *Generator) AddScanList(lt List) {
	g.buf.WriteString(
		makeScanAppendRow(lt.typeName, lt.elemName),
	)
}

// Changes a string's casing to the given format
// The string must be in camel or pascal case
func caseString(str string, cs Case) string {
	if str == "" {
		return str
	}

	r, _ := regexp.Compile("[A-Z]?([A-Z]+|[a-z]+)")
	words := r.FindAllString(str, -1)
	for i := 0; i < len(words); i++ {
		words[i] = strings.ToLower(words[i])
	}

	switch cs {
	case LOWER_CASE:
		return strings.Join(words, "")
	case CAMEL_CASE:
		for i := 1; i < len(words); i++ {
			words[i] = strings.ToUpper(words[i][:1]) + words[i][1:]
		}
		return strings.Join(words, "")

	case PASCAL_CASE:
		for i := 0; i < len(words); i++ {
			words[i] = strings.ToUpper(words[i][:1]) + words[i][1:]
		}
		return strings.Join(words, "")
	case SNAKE_CASE:
		return strings.Join(words, "_")
	case KEBAB_CASE:
		return strings.Join(words, "-")
	}

	return str
}

// Parses the struct tag for alias and omit flag
func parseTag(str string) (alias string, omit bool) {
	tag := reflect.StructTag(str).Get("easyscan")
	if tag == "" {
		return "", false
	}
	tokens := strings.Split(tag, ",")
	if len(tokens) > 1 && tokens[1] == "omit" {
		return tokens[0], true
	}
	return tokens[0], false
}

// Implements the ScanRow function for a struct
func makeScanRow(
	name string,
	fields []string,
	aliases []string,
	anyorder bool,
) string {
	vals := make([]string, len(fields))
	if anyorder {
		for i := 0; i < len(fields); i++ {
			vals[i] = "        case\"" + aliases[i] + "\":\n" +
				"            dets[di] = &o." + fields[i]
		}
		return "func (o *" + name + ") ScanRow(row easyscan.Scannable) error {\n" +
			"    dests, di := make([]interface{}, " + strconv.Itoa(len(vals)) + "), 0\n" +
			"    cols, err := row.ColumnTypes()\n" +
			"    if err != nil {\n" +
			"        return err\n" +
			"    }\n" +
			"    for _, col := range cols {\n" +
			"        switch col.Name() {\n" +
			strings.Join(vals, "\n") + "\n" +
			"    }\n" +
			"    return row.Scan(dests...)\n" +
			"}\n" +
			"\n"
	} else {
		for i := 0; i < len(fields); i++ {
			vals[i] = "        &o." + fields[i] + ","
		}
		return "func (o *" + name + ") ScanRow(row easyscan.Scannable) error {\n" +
			"    return row.Scan(\n" +
			strings.Join(vals, "\n") + "\n" +
			"    )\n" +
			"}\n" +
			"\n"
	}
}

// Implements the ScanAppendRow function for a list
func makeScanAppendRow(
	lname string,
	oname string,
) string {
	return "func (l *" + lname + ") ScanAppendRow(row easyscan.Scannable) error {\n" +
		"    var o " + oname + "\n" +
		"    err := o.ScanRow(row)\n" +
		"    if err != nil {\n" +
		"	    return err\n" +
		"    }\n" +
		"    *l = append([]" + oname + "(*l), o)\n" +
		"    return nil\n" +
		"}\n"
}

